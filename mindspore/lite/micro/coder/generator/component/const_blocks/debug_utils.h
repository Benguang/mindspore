/**
 * Copyright 2021 Huawei Technologies Co., Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MICRO_LITE_MICRO_CODER_GENERATOR_CONST_BLOCKS_BEN_DEBUG_UTILS_H_
#define MICRO_LITE_MICRO_CODER_GENERATOR_CONST_BLOCKS_BEN_DEBUG_UTILS_H_

static const char debug_utils_h[] =
  "/**\n"
  " * Copyright 2021 Huawei Technologies Co., Ltd\n"
  " *\n"
  " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  " * you may not use this file except in compliance with the License.\n"
  " * You may obtain a copy of the License at\n"
  " *\n"
  " * http://www.apache.org/licenses/LICENSE-2.0\n"
  " *\n"
  " * Unless required by applicable law or agreed to in writing, software\n"
  " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
  " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
  " * See the License for the specific language governing permissions and\n"
  " * limitations under the License.\n"
  " */\n"
  "\n"
  "#ifndef MINDSPORE_LITE_MICRO_MICRODEBUGUTIL_H_\n"
  "#define MINDSPORE_LITE_MICRO_MICRODEBUGUTIL_H_\n"
  "\n"
  "#include <stdio.h>\n"
  "#include <sys/time.h>\n"
  "#include <time.h>\n"
  "#include <stdint.h>\n"
  "#include \"microtensor.h\"\n"
  "\n"
  "void PrintTensor(MicroTensor *tensor, FILE *output_file, const char *is_input);\n"
  "\n"
  "void PrintTensorData(MicroTensor *tensor);\n"
  "\n"
  "uint64_t GetTimeUs();\n"
  "\n"
  "#endif  // MINDSPORE_LITE_MICRO_MICRODEBUGUTIL_H_\n";

static const char debug_utils_c[] =
  "/**\n"
  " * Copyright 2021 Huawei Technologies Co., Ltd\n"
  " *\n"
  " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
  " * you may not use this file except in compliance with the License.\n"
  " * You may obtain a copy of the License at\n"
  " *\n"
  " * http://www.apache.org/licenses/LICENSE-2.0\n"
  " *\n"
  " * Unless required by applicable law or agreed to in writing, software\n"
  " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
  " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
  " * See the License for the specific language governing permissions and\n"
  " * limitations under the License.\n"
  " */\n"
  "\n"
  "#include <inttypes.h>\n"
  "#include \"debug_utils.h\"\n"
  "\n"
  "#define UP_DIV(x, y) (((x) + (y) - (1)) / (y))\n"
  "\n"
  "static const unsigned int kPrintNums = 20;\n"
  "static const unsigned int kLineSplitNum = 44;\n"
  "static const unsigned int kLineNum = 45;\n"
  "unsigned int GetTensorElementSize(const MicroTensor *tensor) {\n"
  "  unsigned int ans = 1;\n"
  "  if (tensor->format == Format_NC4HW4) {\n"
  "    for (unsigned int i = 0; i < tensor->ndim; ++i) {\n"
  "      unsigned int dim = tensor->dim[i];\n"
  "      if (i == 1) {\n"
  "        dim = UP_DIV(dim, 4) * 4;\n"
  "      }\n"
  "      ans *= dim;\n"
  "    }\n"
  "  } else {\n"
  "    for (unsigned int i = 0; i < tensor->ndim; ++i) {\n"
  "      ans *= tensor->dim[i];\n"
  "    }\n"
  "  }\n"
  "  return ans;\n"
  "}\n"
  "\n"
  "static const char *const TypeNames[] = {\"DT_FLOAT\", \"DT_FLOAT16\", \"DT_INT8\",   \"DT_INT32\", \"DT_UINT8\",    "
  " \"DT_INT16\",\n"
  "                                        \"\",         \"\",           \"DT_UINT32\", \"DT_INT64\", \"DT_UINT16\",   "
  " \"\",\n"
  "                                        \"\",         \"\",           \"\",          \"\",         "
  "\"DT_UNDEFINED\", \"\"};\n"
  "\n"
  "const char *EnumNameFormat(enum Format e) {\n"
  "  switch (e) {\n"
  "    case Format_NCHW:\n"
  "      return \"NCHW\";\n"
  "    case Format_NHWC:\n"
  "      return \"NHWC\";\n"
  "    case Format_HWKC:\n"
  "      return \"HWKC\";\n"
  "    case Format_HWCK:\n"
  "      return \"HWCK\";\n"
  "    case Format_KCHW:\n"
  "      return \"KCHW\";\n"
  "    case Format_CKHW:\n"
  "      return \"CKHW\";\n"
  "    case Format_KHWC:\n"
  "      return \"KHWC\";\n"
  "    case Format_CHWK:\n"
  "      return \"CHWK\";\n"
  "    case Format_NC4HW4:\n"
  "      return \"NC4HW4\";\n"
  "    case Format_NUM_OF_FORMAT:\n"
  "      return \"NUM_OF_FORMAT\";\n"
  "    default:\n"
  "      return \"\";\n"
  "  }\n"
  "}\n"
  "\n"
  "void PrintTensorData(MicroTensor *tensor) {\n"
  "  void *data = tensor->data;\n"
  "  unsigned int elenums = GetTensorElementSize(tensor);\n"
  "  if (data == NULL || elenums == 0) {\n"
  "    MICRO_ERROR(\"print tensor data failed\");\n"
  "    return;\n"
  "  }\n"
  "  switch (tensor->type) {\n"
  "    case DataType_DT_FLOAT: {\n"
  "      float *addr = (float *)(data);\n"
  "      for (int i = 0; i < elenums && i < kPrintNums; ++i) {\n"
  "        printf(\"%f, \", addr[i]);\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_INT32: {\n"
  "      int32_t *addr = (int32_t *)(data);\n"
  "      for (int i = 0; i < elenums && i < kPrintNums; ++i) {\n"
  "        printf(\"%d, \", addr[i]);\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_INT8: {\n"
  "      int8_t *addr = (int8_t *)(data);\n"
  "      for (int i = 0; i < elenums && i < kPrintNums; ++i) {\n"
  "        printf(\"%d, \", addr[i]);\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_UINT32: {\n"
  "      uint32_t *addr = (uint32_t *)(data);\n"
  "      for (int i = 0; i < elenums && i < kPrintNums; ++i) {\n"
  "        printf(\"%u, \", addr[i]);\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_UINT8: {\n"
  "      uint8_t *addr = (uint8_t *)(data);\n"
  "      for (int i = 0; i < elenums && i < kPrintNums; ++i) {\n"
  "        printf(\"%u, \", addr[i]);\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    default:\n"
  "      MICRO_ERROR(\"unsupported data type %d\", tensor->type);\n"
  "  }\n"
  "  printf(\"\\n\");\n"
  "}\n"
  "\n"
  "void PrintDataToFile(const void *data, const size_t elenums, const enum DataType type, FILE *file) {\n"
  "  if (data == NULL || elenums == 0) {\n"
  "    MICRO_ERROR(\"print tensor data to file failed\");\n"
  "    return;\n"
  "  }\n"
  "  switch (type) {\n"
  "    case DataType_DT_FLOAT: {\n"
  "      float *addr = (float *)(data);\n"
  "      for (int i = 0; i < elenums; ++i) {\n"
  "        fprintf(file, \"%0.15f, \", addr[i]);\n"
  "        if (i % kLineNum == kLineSplitNum) {\n"
  "          fprintf(file, \"\\n\");\n"
  "        }\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_INT32: {\n"
  "      int32_t *addr = (int32_t *)(data);\n"
  "      for (int i = 0; i < elenums; ++i) {\n"
  "        fprintf(file, \"%d, \", addr[i]);\n"
  "        if (i % kLineNum == kLineSplitNum) {\n"
  "          fprintf(file, \"\\n\");\n"
  "        }\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_INT8: {\n"
  "      int8_t *addr = (int8_t *)(data);\n"
  "      for (int i = 0; i < elenums; ++i) {\n"
  "        fprintf(file, \"%d, \", addr[i]);\n"
  "        if (i % kLineNum == kLineSplitNum) {\n"
  "          fprintf(file, \"\\n\");\n"
  "        }\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_UINT32: {\n"
  "      uint32_t *addr = (uint32_t *)(data);\n"
  "      for (int i = 0; i < elenums; ++i) {\n"
  "        fprintf(file, \"%u, \", addr[i]);\n"
  "        if (i % kLineNum == kLineSplitNum) {\n"
  "          fprintf(file, \"\\n\");\n"
  "        }\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    case DataType_DT_UINT8: {\n"
  "      uint8_t *addr = (uint8_t *)(data);\n"
  "      for (int i = 0; i < elenums; ++i) {\n"
  "        fprintf(file, \"%u, \", addr[i]);\n"
  "        if (i % kLineNum == kLineSplitNum) {\n"
  "          fprintf(file, \"\\n\");\n"
  "        }\n"
  "      }\n"
  "      break;\n"
  "    }\n"
  "    default:\n"
  "      MICRO_ERROR(\"unsupported data type %d\", type);\n"
  "  }\n"
  "  fprintf(file, \"\\n\");\n"
  "}\n"
  "\n"
  "void PrintTensor(MicroTensor *tensor, FILE *output_file, const char *is_input) {\n"
  "  if (output_file != NULL) {\n"
  "    MICRO_ERROR(\"output file is NULL\");\n"
  "    return;\n"
  "  }\n"
  "  fprintf(output_file, \"%s \", is_input);\n"
  "  for (int i = 0; i < tensor->ndim; ++i) {\n"
  "    fprintf(output_file, \"%u, \", tensor->dim[i]);\n"
  "  }\n"
  "  fprintf(output_file, \"\\n\");\n"
  "\n"
  "  const char *type = TypeNames[tensor->type];\n"
  "  const char *format = EnumNameFormat(tensor->format);\n"
  "  unsigned int tensorSize = GetTensorElementSize(tensor);\n"
  "  fprintf(output_file, \"%s type:%s, format:%s, elementSize: %u\\n\", is_input, type, format, tensorSize);\n"
  "  fprintf(output_file, \"%s Data:\\n\", is_input);\n"
  "  PrintDataToFile(tensor->data, tensorSize, tensor->type, output_file);\n"
  "  (void)fflush(output_file);\n"
  "}\n"
  "\n"
  "uint64_t GetTimeUs() {\n"
  "  const int USEC = 1000000;\n"
  "  const int MSEC = 1000;\n"
  "  struct timespec ts = {0, 0};\n"
  "  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {\n"
  "    return 0;\n"
  "  }\n"
  "  uint64_t retval = (uint64_t)((ts.tv_sec * USEC) + (ts.tv_nsec / MSEC));\n"
  "  return retval;\n"
  "}\n";

#endif  // MICRO_LITE_MICRO_CODER_GENERATOR_CONST_BLOCKS_BEN_DEBUG_UTILS_H_
